---
layout: post
title: "网络帧同步的原理及实现"
date: 2017-10-18
description: "记录网游的同步技术之一的帧同步的原理，以及主要部分的实现"
tag: 博客 
---   

最近腾讯的手游王者荣耀非常火爆，自己也是沉迷其中的一个玩家，在玩游戏之余也在惊叹手游也能做到这样流畅的网络游戏，不觉自己也想有能力做这样的游戏。进而也想学习学习，随着王者荣耀的的火爆而火起来的帧同步技术。


## 概述
这篇博客记录了我学习帧同步的一些重要思想和实现，这门技术其实在很早之前就有了，魔兽争霸的局域网主机游戏就是先例，虽然原理相同，但这里记录的网络帧同步是基于主机帧同步而进一步向网络端优化出来的技术。


## 概念
网游肯定少不了网络同步，也就是其他玩家的动态也会实时传输到你的屏幕上显示，你做的动作也会实时告诉其他玩家。而同步技术就是在这之上研究总结出来的实现同步的方案，其中常见的就是状态同步和帧同步。状态同步就是玩家控制的角色状态发生改变时就告知其他玩家，这类同步比较常见，传输数据量少，适用于场景角色较多，对同步要求不过于苛求严谨的情况，适合大场景的MMO游戏。帧同步就是让所有客户端每一“帧”显示和数据都一样，像竞技类、格斗类的游戏，它们对于游戏的实时反馈和逻辑处理及精确有非常高的要求，这时候就应该采用帧同步的方式。
帧同步，这里的帧和程序中的update有着类似的定义，程序中的update就是每帧执行一次，而帧同步的目标就是每一帧都和其他玩家同步，但实际情况是每台设备的运行效率不一样，并且网络也没有好到每一帧都能瞬间传输，因此这里的帧定义为另一种帧————同步帧。同步帧的概念就是约定多少时间内固定同步一次，假设我们约定60mm和其他玩家同步一次，那我们称60mm为一同步帧。也可以简单的理解为以60mm时间为限制的回合制游戏的回合。通过这一步步的 同步帧 同步 从而实现所有玩家实时同步，这就是帧同步。帧同步主要能解决网络延迟带来的逻辑判断困难问题，能让同步玩家得到的结果一致，但通信数据量大并且对通信速度较有要求，因此现目前不适合大范围多人同步。

## 原理
举个例子，这里把帧同步看作是每回合60mm时间的回合制游戏，随着时间的推进回合不断的增加，我们都知道回合制游戏就是在一回合内得把所有做的指令都操作好，回合结尾的时候开始展示，而帧同步的的原理和这个类似，你在60mm的同步帧中所做的操作并不立马在你的客户端执行，而是上传到服务器集结处理，服务器在下一同步帧开始的时候把上一同步帧收集到的所有玩家的Action统一发给所有客户端，这时客户端就在新的同步帧中收到了上一帧中所有玩家的操作数据（包括自己）并且可以在客户端中处理所有逻辑了。

## 要点

### 1.逻辑和显示及操作三者分开

客户端与用户的交互程序将会收集起来制作Action,但收集起来的动作并不会立马在客户端执行，因为还需要通知服务器告知其他玩家，因此操作数据单独搜集并不会立马触发逻辑，需要等到下一帧收到服务器下发的所有玩家的Action才开始执行来自服务器下发的所有Action,然后执行它们的逻辑。但是逻辑任然要和显示分开，我们要保证每个客户端计算结果都一样，在收到并处理上一同步帧的逻辑，实现数据统一，然后显示跟上，比如A收到B攻击C的Action，在逻辑处理上C掉不掉血与B释放的技能显示不直接挂钩，这样保证了每个客户端逻辑执行一致计算结果也一致，而显示就可以放在update里面更新也没关系。逻辑和显示分开的另一个好处就是网络波动以及断线重连，当网络不好迟迟没有收到服务端发送的同步帧信息的时候，突然网络变好又收到许多累计下来的帧信息，此时客户端可以快速执行帧信息的逻辑保证数据一致然后让显示跟进就行，而不是依赖显示来计算逻辑。

### 2.警惕浮点数！

在服务器不做逻辑模拟处理以及网络条件限制的情况下，很多逻辑可能只能依靠客户端自己运算，比如行走旋转伤害等，但往往这些计算过程中会出现浮点数，而有浮点数就会出现细微偏差，而这些偏差会在将来累计下来的运算中越来越大形成蝴蝶效应，最终就会导致客户端之间看上去不一样的“平行世界”。在帧同步中这类平行世界出现过后很难排查，所以一定要在编码时就养成好习惯，少用或不用浮点数，使用浮点数也要做精确处理保证计算结果一致。

### 3.物理系统是个大坑

当两个带有钢体的玩家相互碰撞反弹，自带的物理碰撞系统在两个客户端计算结果因为浮点计算很有可能有细微差异，这就又导致了平行世界。王者荣耀在处理边缘碰撞和角色碰撞是自己写的简单物理模拟系统来保证计算结果一直的。主要是评判标准的问题，以其中一个客户端做为标准也是一种解决方法。

### 4.延时不等待

网络帧同步与主机帧同步一个很大的区别在于，主机帧同步中一个玩家卡顿了，所有其他玩家都跟着卡顿，但网络帧同步不会出现这个问题，其主要原因在于网络帧同步的驱动帧是由服务器掌管，随着时间增加同步帧也逐步增加，服务器每帧会固定下发帧数据，当其中一个终端网络卡了，也只是影响他自己接收帧数据，其他终端正常接收。假设当前服务器记录的帧同步到了50帧来了，A的延迟30mm，A输入的Action会顺利地在一帧内传送到服务器，也就是说服务器会在第50帧收到A的动作并且处理然后在第51帧的时候下发给所有客户端。但现在B的延迟有120mm，服务端不可能一直等B发送数据上来，此时服务端帧计算继续执行，只不过接收到B的数据时已经是52帧的时候了，将会在53帧时将B的动作广播给所有客户端，这样B的网络不好也只影响了自己的传输速度，不会对其他玩家造成影响，这就是延时不等待的好处。

### 5.关于网络

帧同步对网络的实时性要求很高，因为所有的输入均要通过服务端统一帧下发后才能处理逻辑，所以这对手感影响极大，对于实时竞技游戏来说更是如此。因此在选择网络传输协议上更偏向UDP而非TCP，当然如今网络越来越好选择TCP也是可以的。在底层上UDP的传输效率是比TCP更快的，但UDP传输存在着丢包、乱序的问题。关于这点，可以在服务端在每帧下发帧数据时带上帧序号，并且每次发送三帧的数据来对抗丢包，这样只要三次通讯中其中一次没有丢就可以正常运行，其实这样丢包的概率已经很小很小了，如过再有丢帧，这就进入补发的流程。中途断线重连以及退出重新进入游戏都是这样处理，断线就从断线帧开始将冗余帧全部发给客户端，退出重进的就从头全部发给客户端，客户端收到冗余帧信息，逻辑快速运算执行，显示跟进就行。
当网络比较波动时好时坏，这时候就有作平滑处理的必要，不管怎样服务端都是当前帧收到Action下帧立马发送，主要是客户端这边要做平滑处理。当网络稍慢没有太及时收到新帧动作，可以做预测处理，比如用户按下了前进按键，就让显示也跟着前进，但当真正帧信息收到过后并且计算出与之前预处理不一致，则需要再修正回来。当网络出现冗余，一下子收到了很多帧信息，通过修改每同步帧中逻辑帧执行数量来控制逻辑执行速度，如果冗余过多，则急速执行逻辑追上，若冗余较少，则较快往前执行逻辑追上就行。